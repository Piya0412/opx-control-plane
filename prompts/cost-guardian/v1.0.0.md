# Cost & Budget Guardian Agent - Logic Specification v1.0.0

**Agent ID:** `cost-guardian`  
**Version:** v1.0.0  
**Date:** 2026-01-25  
**Implementation:** LangGraph Node (Python)  
**Schema Version:** 2026-01  

---

## System Overview

The Cost & Budget Guardian Agent is a **LangGraph node** (NOT a Bedrock Agent) that performs deterministic cost tracking and budget monitoring. It does not use LLM reasoning.

### Why LangGraph Node (Not Bedrock Agent)?

1. **Deterministic arithmetic** - Pure math, no natural language generation
2. **Cost reduction** - No LLM invocation required (zero cost to track costs!)
3. **Replay safety** - Exact reproducibility guaranteed
4. **Performance** - No network latency from Bedrock API calls

### Critical Constraints

1. **Deterministic logic ONLY** - No LLM calls, no randomness
2. **Signal-only behavior** - MUST NOT throw errors or block execution
3. **Non-blocking** - Budget exceeded is a signal, not a blocker
4. **Phase 5 decides** - Control plane determines whether to proceed

---

## Input Format

```python
@dataclass
class CostGuardianInput:
    incident_id: str
    agent_outputs: Dict[AgentId, AgentOutput]  # All prior agent outputs with costs
    budget_remaining: float  # USD, from state
    timestamp: str
```

---

## Output Format

```python
@dataclass
class CostGuardianOutput:
    agent_id: str = "cost-guardian"
    agent_version: str = "1.0.0"
    execution_id: str
    timestamp: str
    duration: int  # milliseconds
    status: ExecutionStatus
    confidence: float = 1.0  # Always 1.0 (deterministic)
    reasoning: str  # Explanation of cost status
    disclaimer: str = "HYPOTHESIS_ONLY_NOT_AUTHORITATIVE"
    
    findings: CostGuardianFindings
    cost: CostMetadata  # Zero cost (no LLM)
    replay_metadata: ReplayMetadata
```

---

## Logic Specification

### Step 1: Aggregate Per-Agent Costs

```python
def aggregate_per_agent_costs(
    agent_outputs: Dict[AgentId, AgentOutput]
) -> Dict[AgentId, AgentCost]:
    """
    Sum costs for each agent.
    
    Args:
        agent_outputs: All agent outputs with cost metadata
    
    Returns:
        Per-agent cost breakdown
    """
    per_agent_costs = {}
    
    for agent_id, output in agent_outputs.items():
        per_agent_costs[agent_id] = AgentCost(
            input_tokens=output.cost.input_tokens,
            output_tokens=output.cost.output_tokens,
            cost=output.cost.estimated_cost
        )
    
    return per_agent_costs
```

### Step 2: Calculate Total Cost

```python
def calculate_total_cost(
    per_agent_costs: Dict[AgentId, AgentCost]
) -> float:
    """
    Sum all agent costs.
    
    Formula:
        total_cost = Î£(agent_cost)
    
    Args:
        per_agent_costs: Per-agent cost breakdown
    
    Returns:
        Total cost in USD
    """
    return sum(cost.cost for cost in per_agent_costs.values())
```

### Step 3: Calculate Budget Remaining

```python
def calculate_budget_remaining(
    budget_remaining: float,
    total_cost: float
) -> float:
    """
    Calculate remaining budget after this incident.
    
    Formula:
        budget_remaining_after = budget_remaining_before - total_cost
    
    Args:
        budget_remaining: Budget before this incident (USD)
        total_cost: Total cost of this incident (USD)
    
    Returns:
        Budget remaining after this incident (USD)
    """
    return budget_remaining - total_cost
```

### Step 4: Check Budget Exceeded

```python
def check_budget_exceeded(
    total_cost: float,
    budget_remaining: float
) -> bool:
    """
    Check if this incident exceeded budget.
    
    IMPORTANT: This is a SIGNAL only, NOT a blocker.
    
    Args:
        total_cost: Total cost of this incident (USD)
        budget_remaining: Budget before this incident (USD)
    
    Returns:
        True if budget exceeded, False otherwise
    """
    return total_cost > budget_remaining
```

### Step 5: Project Monthly Burn

```python
def project_monthly_burn(
    total_cost: float,
    incident_timestamp: str
) -> float:
    """
    Project monthly cost based on current incident cost.
    
    Formula:
        monthly_burn = (total_cost / incidents_per_day) * 30
    
    Assumptions:
        - Average 10 incidents per day (configurable)
        - 30 days per month
    
    Args:
        total_cost: Total cost of this incident (USD)
        incident_timestamp: Incident timestamp (for trend analysis)
    
    Returns:
        Projected monthly burn (USD)
    """
    INCIDENTS_PER_DAY = 10  # Configurable
    DAYS_PER_MONTH = 30
    
    return total_cost * INCIDENTS_PER_DAY * DAYS_PER_MONTH
```

### Step 6: Estimate Incidents Remaining

```python
def estimate_incidents_remaining(
    budget_remaining_after: float,
    total_cost: float
) -> int:
    """
    Estimate how many incidents can be processed before budget exhaustion.
    
    Formula:
        incidents_remaining = floor(budget_remaining_after / avg_cost_per_incident)
    
    Args:
        budget_remaining_after: Budget after this incident (USD)
        total_cost: Total cost of this incident (USD, used as avg)
    
    Returns:
        Estimated incidents remaining (integer)
    """
    if total_cost <= 0:
        return 0  # Cannot estimate with zero cost
    
    return int(budget_remaining_after / total_cost)
```

---

## Complete Implementation

```python
def cost_guardian_agent(state: AgentState) -> AgentState:
    """
    LangGraph node for cost tracking and budget monitoring.
    
    Args:
        state: Current LangGraph state with agent outputs
    
    Returns:
        Updated state with cost guardian findings
    """
    start_time = time.time()
    
    agent_outputs = state["agent_outputs"]
    budget_remaining = state["budget_remaining"]
    
    # Step 1: Aggregate per-agent costs
    per_agent_costs = aggregate_per_agent_costs(agent_outputs)
    
    # Step 2: Calculate total cost
    total_cost = calculate_total_cost(per_agent_costs)
    
    # Step 3: Calculate budget remaining
    budget_remaining_after = calculate_budget_remaining(budget_remaining, total_cost)
    
    # Step 4: Check budget exceeded (SIGNAL ONLY, DO NOT THROW)
    budget_exceeded = check_budget_exceeded(total_cost, budget_remaining)
    
    # Step 5: Project monthly burn
    monthly_burn = project_monthly_burn(total_cost, state["timestamp"])
    
    # Step 6: Estimate incidents remaining
    incidents_remaining = estimate_incidents_remaining(budget_remaining_after, total_cost)
    
    # Build cost guardian output
    cost_guardian_output = CostGuardianOutput(
        execution_id=state["execution_id"],
        timestamp=datetime.utcnow().isoformat(),
        duration=int((time.time() - start_time) * 1000),
        status="SUCCESS",
        confidence=1.0,  # Deterministic calculation
        reasoning=f"Total cost: ${total_cost:.4f}, Budget remaining: ${budget_remaining_after:.2f}, Budget exceeded: {budget_exceeded}",
        findings=CostGuardianFindings(
            total_cost=total_cost,
            budget_remaining=budget_remaining_after,
            budget_exceeded=budget_exceeded,
            per_agent_cost=per_agent_costs,
            projections=CostProjections(
                monthly_burn=monthly_burn,
                incidents_remaining=incidents_remaining
            )
        ),
        cost=CostMetadata(
            input_tokens=0,
            output_tokens=0,
            estimated_cost=0.0,
            model="N/A"
        ),
        replay_metadata=ReplayMetadata(
            deterministic_hash=compute_deterministic_hash(state, total_cost),
            schema_version="1.0.0"
        )
    )
    
    # Update state (DO NOT THROW, EVEN IF BUDGET EXCEEDED)
    state["agent_outputs"]["cost-guardian"] = cost_guardian_output
    state["budget_remaining"] = budget_remaining_after
    
    return state
```

---

## Validation Rules

1. **Determinism:** Same inputs MUST produce same outputs (no randomness)
2. **Confidence:** MUST always be 1.0 (deterministic calculation)
3. **Non-blocking:** MUST NOT throw errors, even if budget exceeded
4. **Zero cost:** Cost MUST be 0.0 (no LLM invocation)
5. **Budget bounds:** Budget remaining can be negative (signal, not blocker)

---

## Testing Requirements

### Unit Tests

- Test per-agent cost aggregation with various costs
- Test total cost calculation
- Test budget remaining calculation (positive and negative)
- Test budget exceeded signal (true and false)
- Test monthly burn projection with various incident rates
- Test incidents remaining estimate (positive, zero, negative budget)

### Integration Tests

- Test with real agent outputs from Phase 6
- Verify deterministic hash matches on replay
- Verify zero cost (no Bedrock API calls)
- Verify execution time <5 seconds
- Verify non-blocking behavior (no exceptions thrown)

---

## Edge Cases

### Budget Exceeded

```python
# Budget exceeded is a SIGNAL, not a blocker
if budget_exceeded:
    # Log warning
    logger.warning(f"Budget exceeded: ${total_cost:.4f} > ${budget_remaining:.2f}")
    
    # Update state with signal
    state["budget_exceeded"] = True
    
    # DO NOT THROW - Phase 5 decides whether to proceed
```

### Negative Budget

```python
# Negative budget is allowed (signal, not blocker)
if budget_remaining_after < 0:
    # Log critical warning
    logger.critical(f"Budget exhausted: ${budget_remaining_after:.2f}")
    
    # Incidents remaining = 0
    incidents_remaining = 0
    
    # DO NOT THROW - Phase 5 decides whether to proceed
```

### Zero Cost Incident

```python
# Zero cost incident (all agents failed or cached)
if total_cost == 0:
    # Cannot project monthly burn or incidents remaining
    monthly_burn = 0.0
    incidents_remaining = 0
    
    # Log info
    logger.info("Zero cost incident (all agents failed or cached)")
```

---

## Disclaimer

**IMPORTANT:** This agent performs **DETERMINISTIC COST TRACKING ONLY**. It does not use LLM reasoning. It provides budget status signals but does NOT block execution.

**Budget exceeded is a SIGNAL, not a BLOCKER.** Phase 5 (automation) decides whether to proceed based on cost signals and other factors.

---

**Version:** v1.0.0  
**Status:** Production  
**Last Updated:** 2026-01-25
